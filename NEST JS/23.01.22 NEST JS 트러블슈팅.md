🚨 트러블은 아닌데
	dto에서 이미 검증을 하였는데 컨트롤에서 validationpipe를 넣는 이유는 뭘까
```ts
import { IsNotEmpty, IsString, Matches, MaxLength, MinLength } from 'class-validator'

export class AuthCredentialDto {

@IsNotEmpty({message : '빈 값은 안되요'})
@IsString({message : '문자열만 올 수 있어요'})
@MinLength(4,{message : '4자 이상이어야 해요'})
@MaxLength(10,{message:'10자 미만만 가능해요'})
username : string

@IsNotEmpty()
@IsString()
@MinLength(4)
@MaxLength(10)
@Matches(/^[a-zA-Z0-9]*$/)
password : string
}
```

```ts
import { ValidationPipe } from '@nestjs/common';
import { AuthCredentialDto } from './dto/auth-credential.dto';
import { AuthService } from './auth.service';
import { Body, Controller, Post } from '@nestjs/common';
import { User } from './user.entity';

@Controller('auth')
export class AuthController {
constructor(private authService : AuthService){}
  
@Post('/signup')
signup(@Body(ValidationPipe) authCredentialDto : AuthCredentialDto) : Promise <User>{
console.log(authCredentialDto)
return this.authService.signup(authCredentialDto)
} 
}
```

결과는 분명 같은데..
